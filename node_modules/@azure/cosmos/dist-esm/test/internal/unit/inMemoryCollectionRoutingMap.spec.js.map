{"version":3,"file":"inMemoryCollectionRoutingMap.spec.js","sourceRoot":"","sources":["../../../../test/internal/unit/inMemoryCollectionRoutingMap.spec.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport assert from \"assert\";\nimport { QueryRange } from \"../../../src/routing\";\nimport { createCompleteRoutingMap } from \"../../../src/routing/CollectionRoutingMapFactory\";\n\ndescribe(\"InMemoryCollectionRoutingMap Tests\", function() {\n  describe(\"getOverlappingRanges\", function() {\n    const partitionKeyRanges = [\n      { id: \"0\", minInclusive: \"\", maxExclusive: \"05C1C9CD673398\" },\n      {\n        id: \"1\",\n        minInclusive: \"05C1C9CD673398\",\n        maxExclusive: \"05C1D9CD673398\"\n      },\n      {\n        id: \"2\",\n        minInclusive: \"05C1D9CD673398\",\n        maxExclusive: \"05C1E399CD6732\"\n      },\n      {\n        id: \"3\",\n        minInclusive: \"05C1E399CD6732\",\n        maxExclusive: \"05C1E9CD673398\"\n      },\n      { id: \"4\", minInclusive: \"05C1E9CD673398\", maxExclusive: \"FF\" }\n    ];\n    const partitionRangeWithInfo = partitionKeyRanges.map((r) => [r, true]);\n    const collectionRoutingMap = createCompleteRoutingMap(partitionRangeWithInfo);\n\n    it(\"queryCompleteRange\", function() {\n      const completeRange = new QueryRange(\"\", \"FF\", true, false);\n      const overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges(\n        completeRange\n      );\n\n      assert.equal(overlappingPartitionKeyRanges.length, partitionKeyRanges.length);\n      assert.deepEqual(overlappingPartitionKeyRanges, partitionKeyRanges);\n    });\n\n    it(\"queryEmptyRange\", function() {\n      const emtpyRange = new QueryRange(\"05C1C9CD673396\", \"05C1C9CD673396\", true, false);\n      const overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges(emtpyRange);\n\n      assert.equal(overlappingPartitionKeyRanges.length, 0);\n    });\n\n    it(\"queryPoint\", function() {\n      const pointRange = new QueryRange(\"05C1D9CD673397\", \"05C1D9CD673397\", true, true);\n      const overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges(pointRange);\n\n      assert.equal(overlappingPartitionKeyRanges.length, 1);\n      assert(overlappingPartitionKeyRanges[0].minInclusive <= pointRange.min);\n      assert(overlappingPartitionKeyRanges[0].maxExclusive > pointRange.max);\n    });\n\n    it(\"boundaryPointQuery\", function() {\n      const pointRange = new QueryRange(\"05C1C9CD673398\", \"05C1C9CD673398\", true, true);\n      const overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges(pointRange);\n\n      assert.equal(overlappingPartitionKeyRanges.length, 1);\n      assert(overlappingPartitionKeyRanges[0].minInclusive <= pointRange.min);\n      assert(overlappingPartitionKeyRanges[0].maxExclusive > pointRange.max);\n      assert(overlappingPartitionKeyRanges[0].minInclusive === pointRange.min);\n    });\n  });\n\n  describe(\"All methods\", function() {\n    const partitionRangeWithInfo = [\n      [\n        {\n          id: \"2\",\n          minInclusive: \"0000000050\",\n          maxExclusive: \"0000000070\"\n        },\n        2\n      ],\n      [\n        {\n          id: \"0\",\n          minInclusive: \"\",\n          maxExclusive: \"0000000030\"\n        },\n        0\n      ],\n      [\n        {\n          id: \"1\",\n          minInclusive: \"0000000030\",\n          maxExclusive: \"0000000050\"\n        },\n        1\n      ],\n      [\n        {\n          id: \"3\",\n          minInclusive: \"0000000070\",\n          maxExclusive: \"FF\"\n        },\n        3\n      ]\n    ];\n\n    const collectionRoutingMap = createCompleteRoutingMap(partitionRangeWithInfo);\n\n    it(\"validate _orderedPartitionKeyRanges\", function() {\n      assert.equal(\"0\", collectionRoutingMap.getOrderedParitionKeyRanges()[0].id);\n      assert.equal(\"1\", collectionRoutingMap.getOrderedParitionKeyRanges()[1].id);\n      assert.equal(\"2\", collectionRoutingMap.getOrderedParitionKeyRanges()[2].id);\n      assert.equal(\"3\", collectionRoutingMap.getOrderedParitionKeyRanges()[3].id);\n    });\n\n    // TODO: bad practice to test implementation details\n    it(\"validate _orderedPartitionInfo\", function() {\n      assert.equal(0, (collectionRoutingMap.orderedPartitionInfo as number[])[0]);\n      assert.equal(1, (collectionRoutingMap.orderedPartitionInfo as number[])[1]);\n      assert.equal(2, (collectionRoutingMap.orderedPartitionInfo as number[])[2]);\n      assert.equal(3, (collectionRoutingMap.orderedPartitionInfo as number[])[3]);\n    });\n\n    it(\"validate getOverlappingRanges\", function() {\n      const completeRange = new QueryRange(\"\", \"FF\", true, false);\n\n      const compareId = function(a: any, b: any): number {\n        // TODO: any\n        return a[\"id\"] - b[\"id\"];\n      };\n\n      const overlappingRanges = collectionRoutingMap\n        .getOverlappingRanges([completeRange])\n        .sort(compareId);\n      assert.equal(4, overlappingRanges.length);\n\n      let onlyParitionRanges = partitionRangeWithInfo.map(function(item) {\n        return item[0];\n      });\n\n      onlyParitionRanges = onlyParitionRanges.sort(compareId);\n      assert.deepEqual(overlappingRanges, onlyParitionRanges);\n\n      const noPoint = new QueryRange(\"\", \"\", false, false);\n      assert.equal(0, collectionRoutingMap.getOverlappingRanges([noPoint]).length);\n\n      const onePoint = new QueryRange(\"0000000040\", \"0000000040\", true, true);\n      let overlappingPartitionKeyRanges = collectionRoutingMap.getOverlappingRanges([onePoint]);\n      assert.equal(1, overlappingPartitionKeyRanges.length);\n      assert.equal(\"1\", overlappingPartitionKeyRanges[0].id);\n\n      const ranges = [\n        new QueryRange(\"0000000040\", \"0000000045\", true, true),\n        new QueryRange(\"0000000045\", \"0000000046\", true, true),\n        new QueryRange(\"0000000046\", \"0000000050\", true, true)\n      ];\n      overlappingPartitionKeyRanges = collectionRoutingMap\n        .getOverlappingRanges(ranges)\n        .sort(compareId);\n\n      assert.equal(2, overlappingPartitionKeyRanges.length);\n      assert.equal(\"1\", overlappingPartitionKeyRanges[0].id);\n      assert.equal(\"2\", overlappingPartitionKeyRanges[1].id);\n    });\n  });\n\n  describe(\"Error Handling\", function() {\n    describe(\"Incorrect instantiation\", function() {\n      it(\"Invalid Routing Map\", function() {\n        const partitionRangeWithInfo = [\n          [\n            {\n              id: \"1\",\n              minInclusive: \"0000000020\",\n              maxExclusive: \"0000000030\"\n            },\n            2\n          ],\n          [\n            {\n              id: \"2\",\n              minInclusive: \"0000000025\",\n              maxExclusive: \"0000000035\"\n            },\n            2\n          ]\n        ];\n        try {\n          createCompleteRoutingMap(partitionRangeWithInfo);\n          assert.fail(\"must throw exception\");\n        } catch (e) {\n          assert.equal(e.message, \"Ranges overlap\");\n        }\n      });\n\n      // TODO: test does two things (code smell)\n      it(\"Incomplete Routing Map\", function() {\n        let partitionRangeWithInfo = [\n          [\n            {\n              id: \"2\",\n              minInclusive: \"\",\n              maxExclusive: \"0000000030\"\n            },\n            2\n          ],\n          [\n            {\n              id: \"3\",\n              minInclusive: \"0000000031\",\n              maxExclusive: \"FF\"\n            },\n            2\n          ]\n        ];\n        let collectionRoutingMap = createCompleteRoutingMap(partitionRangeWithInfo);\n        assert.equal(collectionRoutingMap, null);\n\n        partitionRangeWithInfo = [\n          [\n            {\n              id: \"2\",\n              minInclusive: \"\",\n              maxExclusive: \"0000000030\"\n            },\n            2\n          ],\n          [\n            {\n              id: \"2\",\n              minInclusive: \"0000000030\",\n              maxExclusive: \"FF\"\n            },\n            2\n          ]\n        ];\n        collectionRoutingMap = createCompleteRoutingMap(partitionRangeWithInfo);\n        assert.notEqual(collectionRoutingMap, null);\n      });\n    });\n  });\n});\n"]}