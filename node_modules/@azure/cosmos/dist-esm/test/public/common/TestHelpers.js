import { __rest } from "tslib";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import assert from "assert";
import { CosmosClient } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
const defaultClient = new CosmosClient({
    endpoint,
    key: masterKey,
    connectionPolicy: { enableBackgroundEndpointRefreshing: false }
});
export function addEntropy(name) {
    return name + getEntropy();
}
export function getEntropy() {
    return `${Math.floor(Math.random() * 10000)}`;
}
export async function removeAllDatabases(client = defaultClient) {
    try {
        const { resources: databases } = await client.databases.readAll().fetchAll();
        const length = databases.length;
        if (length === 0) {
            return;
        }
        await Promise.all(databases.map(async (database) => client.database(database.id).delete()));
    }
    catch (err) {
        console.log("An error occured", err);
        assert.fail(err);
        throw err;
    }
}
export async function getTestDatabase(testName, client = defaultClient, attrs) {
    const entropy = Math.floor(Math.random() * 10000);
    const id = `${testName.replace(" ", "").substring(0, 30)}${entropy}`;
    await client.databases.create(Object.assign({ id }, attrs));
    return client.database(id);
}
export async function getTestContainer(testName, client = defaultClient, containerDef, options) {
    const db = await getTestDatabase(testName, client);
    const entropy = Math.floor(Math.random() * 10000);
    const id = `${testName.replace(" ", "").substring(0, 30)}${entropy}`;
    await db.containers.create(Object.assign(Object.assign({}, containerDef), { id }), options);
    return db.container(id);
}
export async function bulkInsertItems(container, documents) {
    return Promise.all(documents.map(async (doc) => {
        const { resource: document } = await container.items.create(doc);
        return document;
    }));
}
export async function bulkReadItems(container, documents, partitionKeyProperty) {
    return Promise.all(documents.map(async (document) => {
        const partitionKey = Object.prototype.hasOwnProperty.call(document, partitionKeyProperty)
            ? document[partitionKeyProperty]
            : undefined;
        // TODO: should we block or do all requests in parallel?
        const { resource: doc } = await container.item(document.id, partitionKey).read();
        assert.deepStrictEqual(doc, document);
    }));
}
export async function bulkReplaceItems(container, documents, partitionKeyProperty) {
    return Promise.all(documents.map(async (document) => {
        const partitionKey = Object.prototype.hasOwnProperty.call(document, partitionKeyProperty)
            ? document[partitionKeyProperty]
            : undefined;
        const { resource: doc } = await container.item(document.id, partitionKey).replace(document);
        const { _etag: _1, _ts: _2 } = document, expectedModifiedDocument = __rest(document, ["_etag", "_ts"]); // eslint-disable-line @typescript-eslint/no-unused-vars
        const { _etag: _4, _ts: _3 } = doc, actualModifiedDocument = __rest(doc, ["_etag", "_ts"]); // eslint-disable-line @typescript-eslint/no-unused-vars
        assert.deepStrictEqual(expectedModifiedDocument, actualModifiedDocument);
        return doc;
    }));
}
export async function bulkDeleteItems(container, documents, partitionKeyProperty) {
    await Promise.all(documents.map(async (document) => {
        const partitionKey = Object.prototype.hasOwnProperty.call(document, partitionKeyProperty)
            ? document[partitionKeyProperty]
            : undefined;
        await container.item(document.id, partitionKey).delete();
    }));
}
export async function bulkQueryItemsWithPartitionKey(container, documents, partitionKeyPropertyName) {
    for (const document of documents) {
        if (!Object.prototype.hasOwnProperty.call(document, partitionKeyPropertyName)) {
            continue;
        }
        const querySpec = {
            query: "SELECT * FROM root r WHERE r." + partitionKeyPropertyName + "=@key",
            parameters: [
                {
                    name: "@key",
                    value: document[partitionKeyPropertyName]
                }
            ]
        };
        const { resources } = await container.items.query(querySpec).fetchAll();
        assert.equal(resources.length, 1, "Expected exactly 1 document");
        assert.equal(JSON.stringify(resources[0]), JSON.stringify(document));
    }
}
// Item
export async function createOrUpsertItem(container, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return container.items.upsert(body, options);
    }
    else {
        return container.items.create(body, options);
    }
}
export async function replaceOrUpsertItem(container, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return container.items.upsert(body, options);
    }
    else {
        const bodyWithId = body;
        return container.item(bodyWithId.id, undefined).replace(body, options);
    }
}
// User
export function createOrUpsertUser(database, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return database.users.upsert(body, options);
    }
    else {
        return database.users.create(body, options);
    }
}
export function createOrUpsertPermission(user, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return user.permissions.upsert(body, options);
    }
    else {
        return user.permissions.create(body, options);
    }
}
export function replaceOrUpsertPermission(user, body, options, isUpsertTest) {
    if (isUpsertTest) {
        return user.permissions.upsert(body, options);
    }
    else {
        return user.permission(body.id).replace(body, options);
    }
}
export function generateDocuments(docSize) {
    const docs = [];
    for (let i = 0; i < docSize; i++) {
        const d = {
            id: i.toString(),
            name: "sample document",
            spam: "eggs" + i.toString(),
            cnt: i,
            key: "value",
            spam2: i === 3 ? "eggs" + i.toString() : i,
            spam3: `eggs${i % 3}`,
            boolVar: i % 2 === 0,
            number: 1.1 * i
        };
        docs.push(d);
    }
    return docs;
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export async function assertThrowsAsync(test, error) {
    try {
        await test();
    }
    catch (e) {
        if (!error || e instanceof error)
            return "everything is fine";
    }
    throw new assert.AssertionError({
        message: "Missing rejection" + (error ? " with " + error.name : "")
    });
}
//# sourceMappingURL=TestHelpers.js.map