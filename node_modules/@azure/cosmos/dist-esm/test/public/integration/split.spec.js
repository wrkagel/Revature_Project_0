import { __asyncValues } from "tslib";
import { bulkInsertItems, getTestContainer, removeAllDatabases } from "../common/TestHelpers";
import { Constants, CosmosClient, PluginOn } from "../../../src";
import { endpoint } from "../common/_testConfig";
import { masterKey } from "../common/_fakeTestSecrets";
import { SubStatusCodes } from "../../../src/common";
import assert from "assert";
const splitError = new Error("Fake Partition Split");
splitError.code = 410;
splitError.substatus = SubStatusCodes.PartitionKeyRangeGone;
const generateDocuments = function (docSize) {
    const docs = [];
    for (let i = 0; i < docSize; i++) {
        docs.push({ id: i.toString() });
    }
    return docs;
};
const documentDefinitions = generateDocuments(20);
describe("Partition Splits", () => {
    let container;
    before(async function () {
        await removeAllDatabases();
        container = await getTestContainer("Partition Splits", undefined, {
            id: "partitionSplits",
            partitionKey: {
                paths: ["/id"]
            }
        }, { offerThroughput: 25100 });
        await bulkInsertItems(container, documentDefinitions);
    });
    it("handles one split part way through iteration", async () => {
        let hasSplit = false;
        const partitionKeyRanges = new Set();
        const options = { endpoint, key: masterKey };
        const plugins = [
            {
                on: PluginOn.request,
                plugin: async (context, next) => {
                    // This plugin throws a single 410 on the *second* time we see the same partition key range ID
                    const partitionKeyRangeId = context === null || context === void 0 ? void 0 : context.headers[Constants.HttpHeaders.PartitionKeyRangeID];
                    if (partitionKeyRanges.has(partitionKeyRangeId) && hasSplit === false) {
                        hasSplit = true;
                        const error = new Error("Fake Partition Split");
                        error.code = 410;
                        error.substatus = SubStatusCodes.PartitionKeyRangeGone;
                        throw error;
                    }
                    if (partitionKeyRangeId) {
                        partitionKeyRanges.add(partitionKeyRangeId);
                    }
                    return next(context);
                }
            }
        ];
        const client = new CosmosClient(Object.assign(Object.assign({}, options), { plugins, connectionPolicy: { enableBackgroundEndpointRefreshing: false } }));
        const { resources } = await client
            .database(container.database.id)
            .container(container.id)
            .items.query("SELECT * FROM root r", { maxItemCount: 2, maxDegreeOfParallelism: 1 })
            .fetchAll();
        // TODO. These should be equal but right now they are not
        // I suspect injecting a random 410 with out actually splitting the documents
        // results in duplicates by trying to read from two partitions
        assert(resources.length >= documentDefinitions.length);
    });
    it("split errors surface as 503", async () => {
        var e_1, _a;
        const options = { endpoint, key: masterKey };
        const plugins = [
            {
                on: PluginOn.request,
                plugin: async (context, next) => {
                    // This plugin throws a single 410 for partition key range ID 0 on every single request
                    const partitionKeyRangeId = context === null || context === void 0 ? void 0 : context.headers[Constants.HttpHeaders.PartitionKeyRangeID];
                    if (partitionKeyRangeId === "0") {
                        const error = new Error("Fake Partition Split");
                        error.code = 410;
                        error.substatus = SubStatusCodes.PartitionKeyRangeGone;
                        throw error;
                    }
                    return next(context);
                }
            }
        ];
        const client = new CosmosClient(Object.assign(Object.assign({}, options), { plugins, connectionPolicy: { enableBackgroundEndpointRefreshing: false } }));
        // fetchAll()
        try {
            await client
                .database(container.database.id)
                .container(container.id)
                .items.query("SELECT * FROM root r", { maxItemCount: 2, maxDegreeOfParallelism: 1 })
                .fetchAll();
            assert.fail("Expected query to fail");
        }
        catch (e) {
            assert.strictEqual(e.code, 503);
        }
        // fetchNext()
        try {
            await client
                .database(container.database.id)
                .container(container.id)
                .items.query("SELECT * FROM root r", { maxItemCount: 2, maxDegreeOfParallelism: 1 })
                .fetchNext();
            assert.fail("Expected query to fail");
        }
        catch (e) {
            assert.strictEqual(e.code, 503);
        }
        // asyncIterator
        try {
            const iterator = client
                .database(container.database.id)
                .container(container.id)
                .items.query("SELECT * FROM root r", { maxItemCount: 2, maxDegreeOfParallelism: 1 })
                .getAsyncIterator();
            const results = [];
            try {
                for (var iterator_1 = __asyncValues(iterator), iterator_1_1; iterator_1_1 = await iterator_1.next(), !iterator_1_1.done;) {
                    const result = iterator_1_1.value;
                    results.push(result);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (iterator_1_1 && !iterator_1_1.done && (_a = iterator_1.return)) await _a.call(iterator_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            assert.fail("Expected query to fail");
        }
        catch (e) {
            assert.strictEqual(e.code, 503);
        }
    });
});
//# sourceMappingURL=split.spec.js.map