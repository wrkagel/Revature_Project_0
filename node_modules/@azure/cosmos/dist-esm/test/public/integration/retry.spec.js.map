{"version":3,"file":"retry.spec.js","sourceRoot":"","sources":["../../../../test/public/integration/retry.spec.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;AAClC,+BAA+B;AAC/B,uFAAuF;AACvF,gDAAgD;AAEhD,QAAQ,CAAC,oBAAoB,EAAE;IAC7B,wBAAwB;IACxB,iCAAiC;IACjC,4BAA4B;IAC5B,KAAK;IAEL,+BAA+B;IAC/B,eAAe;IACf,6BAA6B;IAC7B,iBAAiB;IACjB,KAAK;IAEL,gFAAgF;IAChF,gCAAgC;IAChC,gEAAgE;IAChE,oEAAoE;IACpE,4CAA4C;IAC5C,KAAK;IAEL,yCAAyC;IACzC,kFAAkF;IAClF,8FAA8F;IAC9F,+DAA+D;IAC/D,wEAAwE;IACxE,KAAK;IAEL,2GAA2G;IAC3G,wBAAwB;IACxB,mCAAmC;IACnC,iFAAiF;IACjF,WAAW;IACX,gFAAgF;IAChF,IAAI;IAEJ,6EAA6E;IAC7E,GAAG,CAAC,+CAA+C,EAAE,KAAK;QACxD,uDAAuD;QACvD,iFAAiF;QACjF,iFAAiF;QACjF,gGAAgG;QAChG,gEAAgE;QAChE,sDAAsD;QACtD,4EAA4E;QAC5E,kEAAkE;QAClE,QAAQ;QACR,0CAA0C;QAC1C,6EAA6E;QAC7E,kBAAkB;QAClB,sEAAsE;QACtE,yDAAyD;QACzD,kEAAkE;QAClE,uGAAuG;QACvG,qEAAqE;QACrE,6FAA6F;QAC7F,IAAI;QACJ,sEAAsE;QACtE,0DAA0D;IAC5D,CAAC,CAAC,CAAC;IAEH,GAAG,CAAC,6CAA6C,EAAE,KAAK;QACtD,6DAA6D;QAC7D,8EAA8E;QAC9E,iFAAiF;QACjF,gGAAgG;QAChG,gEAAgE;QAChE,sDAAsD;QACtD,4EAA4E;QAC5E,kEAAkE;QAClE,QAAQ;QACR,yEAAyE;QACzE,iCAAiC;QACjC,kBAAkB;QAClB,sEAAsE;QACtE,yDAAyD;QACzD,kEAAkE;QAClE,uGAAuG;QACvG,qEAAqE;QACrE,gEAAgE;QAChE,6EAA6E;QAC7E,IAAI;QACJ,sEAAsE;QACtE,0DAA0D;IAC5D,CAAC,CAAC,CAAC;IAEH,GAAG,CAAC,0CAA0C,EAAE,KAAK;QACnD,gEAAgE;QAChE,8EAA8E;QAC9E,iFAAiF;QACjF,gGAAgG;QAChG,gEAAgE;QAChE,sDAAsD;QACtD,4EAA4E;QAC5E,kEAAkE;QAClE,QAAQ;QACR,yEAAyE;QACzE,kBAAkB;QAClB,sEAAsE;QACtE,yDAAyD;QACzD,qEAAqE;QACrE,yEAAyE;QACzE,IAAI;QACJ,sEAAsE;QACtE,0DAA0D;IAC5D,CAAC,CAAC,CAAC;IAEH,GAAG,CAAC,8CAA8C,EAAE,KAAK;QACvD,8EAA8E;QAC9E,iFAAiF;QACjF,gGAAgG;QAChG,0DAA0D;QAC1D,sBAAsB;QACtB,iFAAiF;QACjF,QAAQ;QACR,yEAAyE;QACzE,kBAAkB;QAClB,kEAAkE;QAClE,uEAAuE;QACvE,IAAI;QACJ,0DAA0D;IAC5D,CAAC,CAAC,CAAC;IAEH,GAAG,CAAC,4CAA4C,EAAE,KAAK;QACrD,8EAA8E;QAC9E,iFAAiF;QACjF,gGAAgG;QAChG,yGAAyG;QACzG,0DAA0D;QAC1D,sBAAsB;QACtB,iFAAiF;QACjF,qFAAqF;QACrF,+EAA+E;QAC/E,gEAAgE;QAChE,0DAA0D;IAC5D,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n// import assert from \"assert\";\n// import { ConnectionPolicy, Constants, CosmosClient, RetryOptions } from \"../../src\";\n// import * as request from \"../../src/request\";\n\ndescribe(\"retry policy tests\", function() {\n  // this.timeout(300000);\n  // const collectionDefinition = {\n  //   id: \"sample collection\"\n  // };\n\n  // const documentDefinition = {\n  //   id: \"doc\",\n  //   name: \"sample document\",\n  //   key: \"value\"\n  // };\n\n  // mocked database account to return the WritableLocations and ReadableLocations\n  // set with the default endpoint\n  // const mockGetDatabaseAccount = function (options, callback) {\n  //     const databaseAccount = new AzureDocuments.DatabaseAccount();\n  //     callback(undefined, databaseAccount);\n  // };\n\n  // const retryAfterInMilliseconds = 1000;\n  // // mocked request object stub that calls the callback with 429 throttling error\n  // const mockCreateRequestObjectStub = function (connectionPolicy, requestOptions, callback) {\n  //     callback({ code: 429, body: \"Request rate is too large\",\n  //                retryAfterInMilliseconds: retryAfterInMilliseconds });\n  // };\n\n  // var mockCreateRequestObjectForDefaultRetryStub = function (connectionPolicy, requestOptions, callback) {\n  //     global.counter++;\n  //     if (global.counter % 5 == 0)\n  //         return global.originalFunc(connectionPolicy, requestOptions, callback)\n  //     else\n  //         return callback({ code: \"ECONNRESET\", body: \"Connection was reset\" })\n  // }\n\n  // TODO: need to fix this, the stubbing doesn't work with the new way we work\n  xit(\"throttle retry policy test default retryAfter\", async function() {\n    // connectionPolicy.RetryOptions = new RetryOptions(5);\n    // const client = new CosmosClient({endpoint, key: masterKey, connectionPolicy});\n    // const { result: db } = await client.createDatabase({ id: \"sample database\" });\n    // const { result: collection } = await client.createCollection(db._self, collectionDefinition);\n    // const originalGetDatabaseAccount = client.getDatabaseAccount;\n    // client.getDatabaseAccount = mockGetDatabaseAccount;\n    // const originalCreateRequestObjectStub = request._createRequestObjectStub;\n    // request._createRequestObjectStub = mockCreateRequestObjectStub;\n    // try {\n    //     const { result: createdDocument } =\n    //         await client.createDocument(collection._self, documentDefinition);\n    // } catch (err) {\n    //     const responseHeaders = (err as request.ErrorResponse).headers;\n    //     assert.equal(err.code, 429, \"invalid error code\");\n    //     assert.equal(responseHeaders[Constants.ThrottleRetryCount],\n    //         connectionPolicy.RetryOptions.MaxRetryAttemptCount, \"Current retry attempts not maxed out\");\n    //     assert.ok(responseHeaders[Constants.ThrottleRetryWaitTimeInMs]\n    //         >= connectionPolicy.RetryOptions.MaxRetryAttemptCount * retryAfterInMilliseconds);\n    // }\n    // request._createRequestObjectStub = originalCreateRequestObjectStub;\n    // client.getDatabaseAccount = originalGetDatabaseAccount;\n  });\n\n  xit(\"throttle retry policy test fixed retryAfter\", async function() {\n    // connectionPolicy.RetryOptions = new RetryOptions(5, 2000);\n    // const client = new CosmosClient(endpoint, { masterKey }, connectionPolicy);\n    // const { result: db } = await client.createDatabase({ id: \"sample database\" });\n    // const { result: collection } = await client.createCollection(db._self, collectionDefinition);\n    // const originalGetDatabaseAccount = client.getDatabaseAccount;\n    // client.getDatabaseAccount = mockGetDatabaseAccount;\n    // const originalCreateRequestObjectStub = request._createRequestObjectStub;\n    // request._createRequestObjectStub = mockCreateRequestObjectStub;\n    // try {\n    //     await client.createDocument(collection._self, documentDefinition);\n    //     assert.fail(\"Must throw\");\n    // } catch (err) {\n    //     const responseHeaders = (err as request.ErrorResponse).headers;\n    //     assert.equal(err.code, 429, \"invalid error code\");\n    //     assert.equal(responseHeaders[Constants.ThrottleRetryCount],\n    //         connectionPolicy.RetryOptions.MaxRetryAttemptCount, \"Current retry attempts not maxed out\");\n    //     assert.ok(responseHeaders[Constants.ThrottleRetryWaitTimeInMs]\n    //         >= connectionPolicy.RetryOptions.MaxRetryAttemptCount\n    //         * connectionPolicy.RetryOptions.FixedRetryIntervalInMilliseconds);\n    // }\n    // request._createRequestObjectStub = originalCreateRequestObjectStub;\n    // client.getDatabaseAccount = originalGetDatabaseAccount;\n  });\n\n  xit(\"throttle retry policy test max wait time\", async function() {\n    // connectionPolicy.RetryOptions = new RetryOptions(5, 2000, 3);\n    // const client = new CosmosClient(endpoint, { masterKey }, connectionPolicy);\n    // const { result: db } = await client.createDatabase({ id: \"sample database\" });\n    // const { result: collection } = await client.createCollection(db._self, collectionDefinition);\n    // const originalGetDatabaseAccount = client.getDatabaseAccount;\n    // client.getDatabaseAccount = mockGetDatabaseAccount;\n    // const originalCreateRequestObjectStub = request._createRequestObjectStub;\n    // request._createRequestObjectStub = mockCreateRequestObjectStub;\n    // try {\n    //     await client.createDocument(collection._self, documentDefinition);\n    // } catch (err) {\n    //     const responseHeaders = (err as request.ErrorResponse).headers;\n    //     assert.equal(err.code, 429, \"invalid error code\");\n    //     assert.ok(responseHeaders[Constants.ThrottleRetryWaitTimeInMs]\n    //         >= connectionPolicy.RetryOptions.MaxWaitTimeInSeconds * 1000);\n    // }\n    // request._createRequestObjectStub = originalCreateRequestObjectStub;\n    // client.getDatabaseAccount = originalGetDatabaseAccount;\n  });\n\n  xit(\"default retry policy validate create failure\", async function() {\n    // const client = new CosmosClient(endpoint, { masterKey }, connectionPolicy);\n    // const { result: db } = await client.createDatabase({ id: \"sample database\" });\n    // const { result: collection } = await client.createCollection(db._self, collectionDefinition);\n    // global.originalFunc = request._createRequestObjectStub;\n    // global.counter = 0;\n    // request._createRequestObjectStub = mockCreateRequestObjectForDefaultRetryStub;\n    // try {\n    //     await client.createDocument(collection._self, documentDefinition);\n    // } catch (err) {\n    //     assert.equal(err.code, \"ECONNRESET\", \"invalid error code\");\n    //     // assert.equal(global.counter, 6, \"invalid number of retries\");\n    // }\n    // request._createRequestObjectStub = global.originalFunc;\n  });\n\n  xit(\"default retry policy validate read success\", async function() {\n    // const client = new CosmosClient(endpoint, { masterKey }, connectionPolicy);\n    // const { result: db } = await client.createDatabase({ id: \"sample database\" });\n    // const { result: collection } = await client.createCollection(db._self, collectionDefinition);\n    // const { result: createdDocument } = await client.createDocument(collection._self, documentDefinition);\n    // global.originalFunc = request._createRequestObjectStub;\n    // global.counter = 0;\n    // request._createRequestObjectStub = mockCreateRequestObjectForDefaultRetryStub;\n    // const { result: readDocument } = await client.readDocument(createdDocument._self);\n    // assert.equal(readDocument.id, documentDefinition.id, \"invalid document id\");\n    // assert.equal(global.counter, 5, \"invalid number of retries\");\n    // request._createRequestObjectStub = global.originalFunc;\n  });\n});\n"]}